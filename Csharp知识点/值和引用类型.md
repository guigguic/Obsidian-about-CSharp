引用类型：数组，字符串，类
值类型：有符号，无符号，浮点，字符，布尔，结构体
[[变量类型]]
[值和引用知识点](【【唐老狮】Unity系列之C#四部曲—C#基础】 https://www.bilibili.com/video/BV1Kv411s7VG/?p=8&share_source=copy_web&vd_source=1446db144a3fc55e626fbd88ce90699e)13：58 ^db7e81


# 使用上的区别
为更改前
```csharp
//值类型
int a = 10;
//引用类型
int[] arr = new int[]{1,2,3,4,5};

//声明了一个b让其等于之前的a
int b = a;
//声明了一个arr2让其等于之前的arr
int[] arr2 = arr;

console.writeline("a = {0},b = {1}",a,b);   
//打印结果a=10,b=10 
console.writeline("arr[0] = {0},arr2[0] = {1}",arr[0],arr2[0]); 
//打印结果arr[0]=1,arr2[0]=1
```
更改后
```csharp
b = 20;
arr2[0] = 5;
console.writeline("a = {0},b = {1}",a,b);   
//打印结果a=10,b=20 
console.writeline("arr[0] = {0},arr2[0] = {1}",arr[0],arr2[0]); 
//打印结果arr[0]=5,arr2[0]=5
```
让数组不在指向同一堆空间
```csharp
arr2 = new in[]{99,3,2,1};
```
只需要new一个新的数组即可

## 赋值规律
**值类型在相互赋值时** 是把内容拷贝给了对方 他变我不变
**引用类型在相互赋值时** 是把指针指向同一内存地址 他变我也变
## 为什么会有以上的区别
值类型和引用类型 存储在的内存区域是不同的 存储方式是不同的
所以就造成了以上的区别
值类型储存在 栈空间 —— 系统分配，自动回收，小而快
引用类型储存在 堆空间 —— 手动申请和释放，大而慢

# 特殊的引用类型string
string在c#中进行了处理使其具有值类型的特征
虽然方便，但是频繁的改变 string 重新赋值会产生内存垃圾
```csharp
string str1 = "123";
string str2 = str1;
str2 = "321";
//打印结果
//str1 = "123"
//str2 = "321"
//虽是引用类型，但是具有的是值类型的特征 他变我不变
```

# 补充
## **如何判断值类型还是引用类型**
- 按`F12`进到内部查看 
- `class` 就是引用类型
- `struct` 就是值类型

## **语句块**
*命名空间
  ↓
类，接口，结构体
  ↓
函数，属性，索引器，运算符重载等（类，接口，结构体）
  ↓
条件分支，循环*

上层语句块：类，结构体
中层语句块：函数
底层语句块：条件分支 循环等

变量可以声明在哪里
- 上中低：都能声明变量
- 上层语句块中：成员变量
- 中层语句块中：临时变量

##  **变量的生命周期**
- 编程时大部分都是 临时变量
- 在中底层申明的变量（函数，条件分支，循环语句块中）
- 语句块执行结束
- 没有被记录的对象将被回收或者变成垃圾
- 值类型：被系统自动回收
- 引用类型：栈上用于存储地址的房间被系统自动回收，堆中具体内容变成垃圾
- 待下次GC回收
***想要不被回收或者不变成垃圾
必须将其记录下来
如何记录
在更高层级记录或者
使用静态全局变量***

## **结构体中的值和引用**
结构体本身是值类型
*前提：该结构体没有作为其他类的成员*
在结构体中的值，栈中存储值具体的内容
在结构体中的引用，堆中存储引用具体的内容

引用类型始终存储在堆中
真正通过结构体使用其中引用类型时只是顺藤摸瓜

## **类中的值和引用**
类本身是引用类型
在类中的值，堆中存储具体的值
在类中的引用，堆中存储具体的值
***值类型跟着大哥走，引用类型一根筋***

## **数组中的存储规则**
数组本身是引用类型
值类型数组，堆中房间存具体内容
引用类型数组，堆中房间存地址

## **结构体继承接口**
****利用里氏替换原则，用接口容器装载结构体存在装箱拆箱***
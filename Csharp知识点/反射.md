#反射和特性

# 什么是程序集
程序集是经由编译器编译得到的，供进一步编译执行的那个中间产物
在Windows系统中，他的表现为后缀`.dll`（库文件）或者是`.exe`(可执行文件)的格式
*说人话就是*
- 程序集就是我们写的一个代码合集，我们现在写的所有代码
- 最终都会被编译器翻译为一个程序集共别人使用
- 比如一个代码库文件`.dll`或者是一个可执行文件`.exe`
---
# 元数据
元数据就是用来描述数据的数据
这个概念不仅仅用于程序上，在别人领域也有元数据
*说人话就是*
- 程序中的类，类中的函数，变量等等信息就是，数据的元数据
- 有关程序以及类型的数据被称为*元数据* 他们保护在程序集中
---
# 反射的概念
程序正在运行时，可以查看其他程序集或者自身的元数据
有关运行的程序查看本身或者其他程序的元数据的行为叫做反射
*说人话就是*
- 在程序运行时，通过反射可以得到其他程序集或者中间程序集代码的各自的信息
- 类，函数，变量，对象等等，实例他们，操作他们
---
# 反射的作用
**可以在一个文件中 访问另一个文件的东西**
因为反射可以在程序编译后获取信息，所以他们提高了程序的拓展性和灵活性
*程序运行时*
1. 到的所有元数据，包括元数据的特许
2. 实例化对象，操作对象
3. 创建新对象，用这些对象执行任务
---
# 语法相关
申明
```csharp
class Test{
	private int i = 1;
	public int j =0;
	public string str = "123";
	public Test(){
	}
	public Test(int i){
		this.i=i;
	}
	public Test(int i,string str):this(i){
		this.str = str;
	}
	public void Speak(){
		console.writeline(i);
	}
}
//————————————————————————Main
```
## Type
type (类的信息)
它是反射功能的基础
它是访问元数据的主要方式
使用type 的成员获取有关类型声明的信息
有关类型的成员（比如，构造函数，方法，字段，属性，和类的事件）

---
### 获取Type
1. 万物之父`object`中的`GetType()`方法，可以获得对象的Type
```csharp
//————————————————————————Main
int a = 42;
Type tyope = a.GetType();
Console.Writeline(type);
//打印 System.Int32
```
2. 通过`typeof`关键字 传入类名 也可以得到对象的type
```csharp
//————————————————————————Main
Type type2 = typeof(int);
Console.WriteLine(type2);
//打印 System.Int32
```
3. 通过类的名字也可以获得类型
*注意：类名必须包含命名空间，不然找不到*
```csharp
//————————————————————————Main
Type type3 = Type.GetType("System.Int32");
Console.WriteLine(type3);
//打印 System.Int32
```

### 得到类的程序信息
用的比较少
可以通过Type可以得到类型所在程序集信息
```csharp
//————————————————————————Main
Console.WriteLine(type.Assembly);
Console.WriteLine(type2.Assembly);
Console.WriteLine(type3.Assembly);
```
//打印System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e
//打印System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e
//打印System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e
占用的内存空间都是一样的

---
### 获取类中的所有公共成员
1. 需要引用命名空间`using System.Reflection;`
```csharp
//————————————————————————Main
Type t = typeof(Test);  //首先获得Type
MemberInfo[] infos = t.GetMembers;  //然后得到公共成员
for(int i = 0; i<infos.Length;i++){
	Console.WriteLine(infos[i]);
}
```
*打印*
Void Speak()
System.Type GetType()
System.String ToString()
Boolean Equals(System.Object)
Int32 GetHashCode()
Void .ctor()
Void .ctor(Int32)
Void .ctor(Int32, System.String)
Int32 j
System.String str

---
### 获得类的公共构造函数并调用
1. 获取所有构造函数
```csharp
//————————————————————————Main
ConstructorInfo[] ctors = t.GetConstructors();
for(;i<ctors.Lenght;){
	Console.WriteLine(ctors[i]);
}
```
打印
Void .ctor()   *无参构造函数*
Void .ctor(Int32)  *有一个参数的构造函数*
Void .ctor(Int32, System.String)  *有两个参数的构造函数*

2. 获取其中一个`构造函数` 并执行,得构造函数传入 Type数组 数组中内容按顺序是参数类型,执行构造函数传入 object数组 标识按顺序传入的参数
2.1 得到无参构造函数
```csharp
//————————————————————————Main
ConstructorInfo info = t.GetConstructor(new Type[0]);
Test obj = info.Invoke(null) as Test;
//或者
info.Invoke(null);  //0
```
 2.2 得到有参构造函数
 ```csharp
//————————————————————————Main
ConstructorInfo info2 = t.GetConstructor
	(new Type[]{typeof(int)});
Console.WriteLine(obj.Str);  //123

ConstructorInfo info3 = t.GetConstructor
	(new Type[]{typeof(int),typeof(stirng)});
obj = info3.Invoke(new object[]{4,"44444"}) as Test;
Console.WriteLine(obj.str);  //44444
```

### 获取类中的公共成员变量
1. 得到所有成员变量
```csharp
//————————————————————————Main
FieldInfo[] fieldInfo = t.GetFields();
for(;i<fieldInfo.Length;){
	Console.WriteLine(fieldInfos[i]);
}
//打印
//Int32 j
//System.String str
```

2. 得到指定名称的公共成员变量
```csharp
//————————————————————————Main
FieldInfo infoJ = t.GetField("j");
Console.WriteLine(infoJ);
//打印 Int32 j
```

3. 通过反射获取和设置对象的值
重新赋值
```csharp
//————————————————————————Main
Test test = new Test();
test.j = 99;
test.str = "2222";
```
3-1 通过反射 获取对象的某个变量的值
```csharp
//————————————————————————Main
Console.WriteLine(infoJ.GetValue(test));
//打印99
```
3-2 通过反射 设置指定对象的某个变量的值
```csharp
//————————————————————————Main
infoJ.SetValue(test,100);
Console.WriteLine(infoJ.GetValue(test));
//打印100
```

### 获得类中的公共成员方法
通过Type类中的 `GetMehod`方法 得到类中的方法
`MethodInfo` 是方法得反射信息
`Type strType = typeof(string);`  申明
1. 如果存在方法重载 用Type数组标识参数类型
```csharp
MethodInfo[] methods = strType.GetMethods();
for(int i = 0; i < methods.Length; i++){
    Console.WriteLine(methods[i]);
}
//这里会把stirng里的所有方法都打印出来
```
1-1 指定方法
```csharp
MethodInfo subStr = strType.GetMethod("Substring",
	new Type[]{typeof(int),typeof(int)});
```

2. 调用该方法
注意：如果是静态方法 Invoke中的第一个参数传`null`即可
```csharp
string str = "hello,world!";
//第一个对象 相当于 是哪个对象要执行这个成员方法
objcet result = subStr.Invoke
	(str,new object[]{7,5});
Console.WriteLine(result);
//打印 orld!
```

### 其他
Type
得枚举
GetEnumName
GetEnumNames

得事件
GetEvent
GetEvents

得接口
GetInterface
GetInterfaces

得属性
GetProperty
GetPropertys
等等
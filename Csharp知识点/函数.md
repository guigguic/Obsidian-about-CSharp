#函数
# 基本概念
在编程中，**函数**（也称为方法）是一个独立的代码块，包含一组指令，用于执行特定的任务。函数通常具有输入、逻辑处理、输出三部分，目的是让代码更具模块化、易读性和可重用性。
### 函数的主要特点

1. **封装性**：函数可以将某一逻辑封装起来，使其独立于其他代码部分，避免重复编写相同的代码。
    
2. **可重用性**：编写一次函数后，可以在多个地方调用该函数，减少代码重复，提升开发效率。
    
3. **参数和返回值**：
    
    - 函数可以接收参数（输入），即调用时传递的数据，用来影响函数的行为或输出。
    - 函数可以返回一个值（输出），即函数执行的结果。
4. **作用范围**：函数内定义的变量和逻辑只在函数内部生效，不影响外部代码。
    
### 函数的结构

函数通常包括以下几个部分：

- **函数名**：用于标识和调用函数。
- **参数列表**：即输入，放在函数名后面的括号中，用来接收调用时传入的数据。
- **返回类型**：定义函数的返回值类型（某些编程语言中不强制要求）。
- **函数体**：函数内部的代码，包含实现功能的逻辑。
### 函数的好处

- **提升代码的清晰度**：通过分解复杂的任务，每个函数只负责一项工作，使得代码更清晰。
- **便于调试和维护**：独立的代码块更易于调试和更改。
- **增加代码的复用性**：函数可以在不同的地方调用，减少代码冗余。
### 示例

比如在计算两个数字之和的场景中，可以创建一个加法函数，不必重复写加法操作。
### 总结
函数（方法）
是封装代码进行重复使用的一种机制
提升复用率
抽象行为

==函数在 **class**，**struct** 中声明==
==**关键字：static**(静态的)，**void**(无返回值)==
==**函数的命名：**每一个首单词大写 帕斯卡命名法==
返回类型 可以是任意变量类型
参数不是必须的 参数类型也可以是任意类型
**参数默认值/可选参数**：当参数给定默认值时，使用函数时不传入参数就会使用参数默认值来进行计算
可以嵌套使用

return可以提前结束函数逻辑，直接返回到函数外部
与for，while中的break有些相似

# 基本语法
格式
==函数在 **class**，**struct** 中声明==
==**关键字：static**(静态的)，**void**(无返回值)==
return可以提前结束函数逻辑，直接返回到函数外部
与for，while中的break有些相似
```csharp
namespace
{
    internal class program
    {
	    //static 返回类型 函数名 （参数，参数名...）;
	    //{
			//代码逻辑
			//return 返回值；（有返回类型才写）
	    //}
	    static int Function (int a , int b );
	    {
			int c = a*b;
			return c ;
	    }
	    
        static void Main(string[] args)
        {
            
        }
    }
}
```
## 函数的声明
```csharp
//⭕1.无参无返回值函数
static void SayHellow()
{
    Console.WriteLien("你好世界");
}

//⭕2.有参无返回值函数
static void SayYourName (string name)
{
    Console.WriteLien("你的名字是{0}",name);	
}

//⭕3.无参有返回值函数
static string WhatYouName ()
{
    return "小曾";
}

//⭕4.有参有返回值函数
static int Multiply (int a ,int b)
{
    int c = a*b;
    return c;
}

//⭕5.有参数多返回值函数
//传入两个数 然后计算两数的和以及平均数 得出结果返回
//函数返回值默认是不能返回多个变量，可以使用数组来储存 
static int[] Calc (int a ,int b)
{
    int sum = a+b;
    int avg = (a+b)/2;
    int[] array = {sum,avg};
    return array;
}

//⭕6.return可以直接不执行之后的代码，直接返回到函数外部
static void Speak (string str)
{
    //如果说你好就不打印
    if(str == "你好")
    {
        return "";
    }
    Console.WriteLien(str);	
}
```
# ref和out

^5967aa

他们使用的方式和效果都是一样，在参数前添加
使传入的参数 在函数外也修改
相当于直接使用这个传入参数，而不是声明一个参数取替代
在函数中new 传入数组的时候 ，真正的new了

**ref和out的区别：**
**1.ref传入的变量(参数) 必须初始化，out不用。**
**2.out传入的变量必须在内部赋值，ref不用。**
```csharp
static void ChangeValue (int a)
{
    a=20;
}
//———————————————————————— Main
int b = 10
ChangeValue(b);
//打印b还是为10


//参数前添加 ref 修饰符 
static void ChangeValue ( ref int a)
{
    a=20;
}
//———————————————————————— Main
int b = 10
ChangeValue(b);
//打印b为20 在函数内修改传入参数 传入的参数在外部也会修改
```
# params变长参数
可以输入不定的多个参数，并把这些参数存入数组
```csharp
//例子求和输入的参数
static int Sum(params int[] arr)
{
    int sum = 0;
    for (int i = 0; i < arr.Length; i++)
    {
        sum += arr[i];
    }
    return sum;
}
//———————————————————— Main
int sum = Sum(1,2,3,4,5,6);
Console.WriteLine(sum);
//打印sum为21
```
在函数参数中只能最多出现一个params关键字 且一定在最后一组参数
```csharp
static int Sum(int a ,int b ,params int[] arr)
{
    return 0;
}
```
# 函数重载
在同一语句块（class或struct）中函数名相同 参数的数量or类型or顺序不同。
系统根据 参数:数量,类型,顺序 的不同来重载不同的函数。
与返回值类型无关 返回值类型可以是任意类型

**作用：命名一组功能类似的函数，减少函数名的数量，避免命名空间的污染，提升程序的可读性**
```csharp
static int CalcSum(int a ,int b)
{
    return a+b;
}

//参数数量不同
static int CalcSum(int a ,int b,int c)
{
    return a+b+c;
}

//参数类型不同
static float CalcSum(float a ,float b)
{
    return a+b;
}

//参数顺序不同
static float CalcSum(int a , float b)
{
    return a+b;
}
static float CalcSum(float b ，int a )
{
    return b+a;
}

//ref和out
static float CalcSum(ref float b ，int a )
{
    return b+a;
}
//----------------------------------------------------

//虽然函数名相同，但系统根据 参数:数量,类型,顺序 的不同来重载不同的函数。
CalcSum(1,2);
CalcSum(1,2,3);
CalcSum(1.11f,2.22f);
CalcSum(1,2.22f);
CalcSum(2.22f,1);
```
# 递归函数
==让函数自己调用自己
必须有结束调用的条件
比较难且实际开发用的不多，面试客户端会有==

**递归函数**是指在其定义或实现过程中直接或间接调用自身的函数。在编程中，递归是一种解决问题的方法，通过将复杂的问题分解为更简单的子问题，直到达到一个基本情况（基准情况）为止。

### 递归函数的组成部分

1. **递归调用（Recursive Call）**：
    - 函数在其内部调用自身，以处理更小或更简单的子问题。
2. **基准情况（Base Case）**：
    - 一个不需要进一步递归调用的简单情况，用于终止递归过程，防止无限递归。

### 递归的工作原理

递归通过重复调用自身，将问题分解为更小的部分，逐步逼近基准情况。每次递归调用都会创建一个新的函数执行上下文，直到满足基准情况，递归开始回溯，逐层返回结果。

### 递归的优点

1. **简洁性**：
    - 递归函数通常比其迭代（如循环）对应版本更简洁、更易于理解，特别是在处理具有重复结构的问题时，如树结构、图遍历等。
2. **自然适应某些问题**：
    - 某些问题，如分形、树的遍历、组合问题，天然适合使用递归来解决。

### 递归的缺点

1. **性能问题**：
    - 递归调用会消耗更多的内存和处理时间，因为每次调用都会在调用栈上创建一个新的执行上下文。
2. **可能导致栈溢出**：
    - 如果递归深度过大，可能会导致调用栈溢出（Stack Overflow），特别是在没有正确设置基准情况时。

### 递归的应用场景

1. **数学问题**：
    - 计算阶乘、斐波那契数列等。
2. **数据结构**：
    - 遍历树结构（如二叉树、文件系统）、图的遍历（如深度优先搜索）。
3. **分治算法**：
    - 诸如快速排序、归并排序等算法，通过递归将问题分解为更小的部分来解决。
4. **组合与排列**：
    - 生成所有可能的组合或排列，如全排列问题、子集生成等。

### 举例说明

虽然您要求不需要代码演示，但理解递归函数的工作方式对于掌握编程中的递归概念非常重要。以下是一个简化的例子说明：

**问题**：计算一个数的阶乘（例如，5! = 5 × 4 × 3 × 2 × 1）。

**递归思路**：

- **阶乘定义**：
    - 0! = 1（基准情况）
    - n! = n × (n-1)!（递归调用）

通过这种定义，可以看到每一步递归都在计算更小的阶乘，直到达到基准情况。

### 总结

递归是一种强大且灵活的编程技术，适用于解决那些可以被分解为相似子问题的问题。然而，使用递归时需要谨慎，确保基准情况的存在以及递归调用能够逐步逼近基准情况，以避免性能问题和栈溢出错误。理解递归的基本原理和应用场景，对于成为一名熟练的程序员尤为重要。
```csharp
//用递归函数计算阶乘的代码
 static int Factorial(int n){
  // 基准情况：0! 和 1! 都等于 1
	if (n <= 1){
	return 1;
	}
	// 递归情况：n! = n * (n-1)!
	else
	return n * Factorial(n - 1);}
}
//—————————————————————————— Main
int number = 5;
int result = Factorial(number);
Console.WriteLine($"{number}! = {result}");

```
### 代码说明

1. **`Main` 方法**：
    
    - 这里定义了一个整数 `number` 并调用 `Factorial` 函数计算它的阶乘。
    - 打印计算结果。
2. **`Factorial` 方法**：
    
    - **基准情况**：当 `n` 为 0 或 1 时，返回 1，因为 0! 和 1! 的值都是 1。
    - **递归调用**：否则返回 `n * Factorial(n - 1)`，即调用自身，传入 `n - 1` 作为参数。

### 示例输出

运行这段代码时，输出结果为：

复制代码

`5! = 120`

### 递归过程

计算 `5!` 时，递归调用的过程如下：

- `Factorial(5)` 调用 `5 * Factorial(4)`
- `Factorial(4)` 调用 `4 * Factorial(3)`
- `Factorial(3)` 调用 `3 * Factorial(2)`
- `Factorial(2)` 调用 `2 * Factorial(1)`
- `Factorial(1)` 返回 `1`（基准情况）

递归回溯时，结果逐步相乘得到 `5 * 4 * 3 * 2 * 1 = 120`。